---
title: 正则
date: 2022-06-16
categories:
  - js
tags:
  - Reg
---

:::tip
此文根据《JavaScript 正则表达式》编写，可以去看看该书籍去学习正则。
:::

# 一、正则表达式字符匹配攻略

## 1.1 两种模糊匹配

### 1.1.1 横向模糊匹配 ｛｝

:::tip

&emsp;&emsp;横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。
其实现的方式是使用量词。譬如 **{m,n}**，表示连续出现最少 m 次，最多 n 次

:::

```js
var regex = /ab{2,5}c/g;
var string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";
console.log(string.match(regex));
// => ["abbc", "abbbc", "abbbbc", "abbbbbc"]
```

### 1.1.1 纵向模糊匹配 [ ]

:::tip

&emsp;&emsp;纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。其实现的方式是使用字符组。譬如 **[abc]**，表示该字符是可以字符 "a"、"b"、"c" 中的任何一个。

:::

## 1.2 字符组

### 1.2.1 范围表示法 -

&emsp;&emsp;当前字符组里的字符特别多的话，可以使用范围表示法。例如：[123456abcdefGHIJKLM]， 可以写成 [1-6a-fG-M]。用**连字符 - **表示省略和简写。 如果要匹配 - ,可以使用转义 \-

### 1.2.2 排除字符组 ^

&emsp;&emsp;纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是 "a"、"b"、"c"。
此时就是排除字符组（反义字符组）的概念。例如 [^abc]，表示是一个除 "a"、"b"、"c"之外的任意一个字符。

&emsp;&emsp;字符组的第一位放 ^（脱字符），表示求反的概念。

### 1.2.3 常见简写形式

| 字符组 | 具体含义                                                                                                                                                                          |
| ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| \d     | 表示 [0-9]。表示是一位数字。<br/>记忆方式：其英文是 digit（数字）。                                                                                                               |
| \D     | 表示 [^0-9]。表示除数字外的任意字符。                                                                                                                                             |
| \w     | 表示 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。<br/>记忆方式：w 是 word 的简写，也称单词字符。                                                                                  |
| \W     | 表示 [^0-9a-za-z_]。非单词字符。                                                                                                                                                  |
| \s     | 表示 [ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页<br/>符。<br/>记忆方式：s 是 space 的首字母，空白符的单词是 white space。                   |
| \S     | 表示 [^ \t\v\n\r\f]。 非空白符。                                                                                                                                                  |
| .      | 表示 [^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符<br/>除外。<br/>记忆方式：想想省略号 … 中的每个点，都可以理解成占位符，表示任何类似的东西。 |

## 1.3 量词

&emsp;&emsp;量词也称重复。掌握 {m,n} 的准确含义后，只需要记住一些简写形式。

### 1.3.1 简写形式

| 量词 | 具体含义                                                                                                                   |
| ---- | -------------------------------------------------------------------------------------------------------------------------- |
| {m,} | 表示至少出现 m 次。                                                                                                        |
| {m}  | 等价于 {m,m}，表示出现 m 次                                                                                                |
| ?    | 等价于 {0,1}，表示出现或者不出现。<br/>记忆方式：问号的意思表示，有吗？                                                    |
| +    | 等价于 {1,}，表示出现至少一次。<br/>记忆方式：加号是追加的意思，得先有一个，然后才考虑追加。                               |
| \*   | 等价于 {0,}，表示出现任意次，有可能不出现。<br/>记忆方式：看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过来。 |

### 1.3.2 贪婪匹配与惰性匹配

看如下的例子：

```js
var regex = /\d{2,5}/g;
var string = "123 1234 12345 123456";
console.log(string.match(regex));
// => ["123", "1234", "12345", "12345"]
```

&emsp;&emsp;其中正则 /\d{2,5}/，表示数字连续出现 2 到 5 次。会匹配 2 位、3 位、4 位、5 位连续数字。
但是其是贪婪的，它会尽可能多的匹配。你能给我 6 个，我就要 5 个。你能给我 3 个，我就要 3 个。
反正只要在能力范围内，越多越好。
&emsp;&emsp;我们知道有时贪婪不是一件好事，而惰性匹配，就是尽可能少的匹配：

```js
var regex = /\d{2,5}?/g;
var string = "123 1234 12345 123456";
console.log(string.match(regex));
// => ["12", "12", "34", "12", "34", "12", "34", "56"]
```

&emsp;&emsp;其中 /\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了。

&emsp;&emsp;通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：

| 惰性量词 | 贪婪量词 |
| -------- | -------- |
| {m,n}?   | {m,n}    |
| {m,}?    | {m,}     |
| ??       | ?        |
| +?       | +        |
| \*?      | \*       |

## 1.4 多选分支

&emsp;&emsp;一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 |（管道符）分隔，表示其中任何之一。

&emsp;&emsp;例如要匹配字符串 "good" 和 "nice" 可以使用 /good|nice/。

```js
var regex = /good|nice/g;
var string = "good idea, nice try.";
console.log(string.match(regex));
// => ["good", "nice"]
```

:::tip
**分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了**
:::

## 1.5 案例

### 1.5.1 匹配 16 进制颜色值

```js
#ffbbad
#Fc01DF
#FFF
#ffE

var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g
var string = "#ffbbad #Fc01DF #FFF #ffE";
console.log( string.match(regex) );
// => ["#ffbbad", "#Fc01DF", "#FFF", "#ffE"]
```

### 1.5.2 匹配时间

```js
23：59
02：07
var regex = /^([01]\d|2[0-3]):[0-5][0-9]$/
console.log( regex.test("23:59") );
console.log( regex.test("02:07") );
// => true
// => true
```

### 1.5.3 匹配日期

&emsp;&emsp;以 yyyy-mm-dd 格式为例。

```js
2017 - 06 - 10;

var regex = /^\d{4}-(0\d|1[0-2])-(0\d|[12]\d|3[01])$/;
console.log(regex.test("2017-06-10"));
// => true
```

### 1.5.4 window 操作系统文件路径

```
要求匹配以下内容：
F:\study\javascript\regex\regular expression.pdf
F:\study\javascript\regex\
F:\study\javascript
F:\
```

```js
var regex = /^[a-zA-Z]:\\([^\\:*<>|"?\r\n/]+\\)*([^\\:*<>|"?\r\n/]+)?$/;
console.log(regex.test("F:\\study\\javascript\\regex\\regular expression.pdf"));
console.log(regex.test("F:\\study\\javascript\\regex\\"));
console.log(regex.test("F:\\study\\javascript"));
console.log(regex.test("F:\\"));
// => true
// => true
// => true
// => true
```

### 1.5.5 匹配 id

```
<div id="container" class="main"></div>  提取出 id="container"
```

```js
var regex = /id=".*?"/;
var string = '<div id="container" class="main"></div>';
console.log(string.match(regex)[0]);
```

```js
var regex = /id="[^"]*"/;
var string = '<div id="container" class="main"></div>';
console.log(string.match(regex)[0]);
// => id="container"
```

# 二、正则表达式位置匹配攻略

:::tip

&emsp;&emsp;正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话

:::

## 2.1 什么是位置呢？

&emsp;&emsp;**位置（锚）是相邻字符之间的位置。**

## 2.2 如何匹配位置呢？

&emsp;&emsp;在 ES5 中，共有 6 个锚：

&emsp;&emsp;`^`&emsp;`$`&emsp;`\b`&emsp;`\B`&emsp;`(?=p)`&emsp;`(?|p)`

### 2.2.1 ^ 和 $

^ ( 脱字符 ）匹配开头，在多行匹配中匹配行开头。

$ ( 美元符号 ) 匹配结尾，在多行匹配中匹配行结尾。

例如将字符串的开头和结尾使用" # "替换 ( 位置可以替换成字符的！) ：

```js
var result = "hello".replace(/^|$/g, "#");
console.log(result);
// => "#hello#"
```

多行匹配模式（即有修饰符 m）时，二者是行的概念，这一点需要我们注意：

```js
var result = "I\nlove\njavascript".replace(/^|$/gm, '#');
console.log(result);
/*
#I#
#love#
#javascript#
*
```

### 2.2.2 \b 和 \B

&emsp;&emsp;\b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置， 和 \w 与 $ 之间的位置。比如考察文件名 "[JS] Lesson_01.mp4" 中的 \b，如下：

```js
var result = "[JS] Lesson_01.mp4".replace(/\b/g, "#");
console.log(result);
// => "[#JS#] #Lesson_01#.#mp4#"
```

&emsp;&emsp;为什么是这样呢？这需要仔细看看。

&emsp;&emsp;首先，我们知道，\w 是字符组 [0-9a-zA-Z_] 的简写形式，即 \w 是字母数字或者下划线的中任何一个字
符。而 \W 是排除字符组 [^0-9a-za-z_] 的简写形式，即 \W 是 \w 以外的任何一个字符。
此时我们可以看看 "[#JS#] #Lesson_01#.#mp4#" 中的每一个井号 ，是怎么来的。

• 第 1 个，两边字符是 "[" 与 "J"，是 \W 与 \w 之间的位置。<br>
• 第 2 个，两边字符是 "S" 与 "]"，也就是 \w 与 \W 之间的位置。<br>
• 第 3 个，两边字符是空格与 "L"，也就是 \W 与 \w 之间的位置。<br>
• 第 4 个，两边字符是 "1" 与 "."，也就是 \w 与 \W 之间的位置。<br>
• 第 5 个，两边字符是 "." 与 "m"，也就是 \W 与 \w 之间的位置。<br>
• 第 6 个，位于结尾，前面的字符 "4" 是 \w，即 \w 与 $ 之间的位置。

&emsp;&emsp;知道了 \b 的概念后，那么 \B 也就相对好理解了。

&emsp;&emsp;\B 就是 \b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \b，剩下的都是 \B 的。
具体说来就是 \w 与 \w、 \W 与 \W、^ 与 \W，\W 与 $ 之间的位置。

&emsp;&emsp;比如上面的例子，把所有 \B 替换成 "#"：

```js
var result = "[JS] Lesson_01.mp4".replace(/\B/g, "#");
console.log(result);
// => "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"
```

### 2.2.3 (?=p) 和 (?|p)

&emsp;&emsp;(?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。
比如 (?=l)，表示 "l" 字符前面的位置，例如：

```js
var result = "hello".replace(/(?=l)/g, "#");
console.log(result);
// => "he#l#lo"
```

&emsp;&emsp;而 (?!p) 就是 (?=p) 的反面意思，比如：

```js
var result = "hello".replace(/(?!l)/g, "#");
console.log(result);
// => "#h#ell#o#"
```

## 2.3 位置的特性

:::tip

&emsp;&emsp;把位置理解空字符，是对位置非常有效的理解方式。

:::

比如 "hello" 字符串等价于如下的形式：

```js
"hello" == "" + "h" + "" + "e" + "" + "l" + "" + "l" + "" + "o" + "";
```

也等价于：

```js
"hello" == "" + "" + "hello";
```

因此把 /^hello$/ 写成 /^^hello$$$/，是没有任何问题的。

```js
var result = /^^hello$$$/.test("hello");
console.log(result);
// => true
```

甚至可以写成更复杂的：

```js
var result = /(?=he)^^he(?=\w)llo$\b\b$/.test("hello");
console.log(result);
// => true
```

也就是说字符之间的位置，可以写成多个。

## 2.4 相关案例

### 2.4.1 不匹配任何东西的正则

让你个正则不去匹配任何东西

`/.^/`

因为此正则要求只有一个字符，但该字符后面是开头，而这样的字符串是不存在的。

### 2.4.2 数字的千位分隔符表示法

比如把 "12345678"，变成 "12,345,678"。
可见是需要把相应的位置替换成 ","。
思路是什么呢？

#### 2.4.2.1. 弄出最后一个逗号

使用 (?=\d{3}$) 就可以做到：

```js
var result = "12345678".replace(/(?=\d{3}$)/g, ",");
console.log(result);
// => "12345,678"
```

其中，(?=\d{3}$) 匹配 \d{3}$前面的位置。而 \d{3}$ 匹配的是目标字符串最后那 3 位数字。

#### 2.4.2.2 弄出所有的逗号

因为逗号出现的位置，要求后面 3 个数字一组，也就是 \d{3} 至少出现一次。

此时可以使用量词 +：

```js
var result = "12345678".replace(/(?=(\d{3})+$)/g, ",");
console.log(result);
// => "12,345,678"
```

#### 2.4.2.3 匹配其余案例

写完正则后，要多验证几个案例，此时我们会发现问题：

```js
var result = "123456789".replace(/(?=(\d{3})+$)/g, ",");
console.log(result);
// => ",123,456,789"
// &emsp;&emsp;
```

&emsp;&emsp;因为上面的正则，仅仅表示把从结尾向前数，一但是 3 的倍数，就把其前面的位置替换成逗号。因此才会出现这个问题。
&emsp;&emsp;怎么解决呢？我们要求匹配的到这个位置不能是开头。
&emsp;&emsp;我们知道匹配开头可以使用 ^，但要求这个位置不是开头怎么办？

&emsp;&emsp;easy，(?!^)，你想到了吗？测试如下：

```js
var regex = /(?!^)(?=(\d{3})+$)/g;
var result = "12345678".replace(regex, ",");
console.log(result);
// => "12,345,678"
result = "123456789".replace(regex, ",");
console.log(result);
// => "123,456,789"
```

#### 2.4.2.4 支持其他形式

&emsp;&emsp;如果要把 "12345678 123456789" 替换成 "12,345,678 123,456,789"。

&emsp;&emsp;此时我们需要修改正则，把里面的开头 ^ 和结尾 $，修改成 \b：

```js
var string = "12345678 123456789",
  regex = /(?!\b)(?=(\d{3})+\b)/g;
var result = string.replace(regex, ",");
console.log(result);
// => "12,345,678 123,456,789"
```

&emsp;&emsp;其中 (?!\b) 怎么理解呢？
&emsp;&emsp;要求当前是一个位置，但不是 \b 前面的位置，其实 (?!\b) 说的就是 \B。
&emsp;&emsp;因此最终正则变成了：/\B(?=(\d{3})+\b)/g。

#### 2.4.2.5 格式化

&emsp;&emsp;千分符表示法一个常见的应用就是货币格式化。例如：

```
1888 => $1888.00
```

```js
function format(num) {
  return num
    .toFixed(2)
    .replace(/\B(?=(\d{3})+\b)/g, ",")
    .replace(/^/, "$$ ");
}
console.log(format(1888));
// => "$ 1,888.00"
```

### 2.4.3 验证密码问题

&emsp;&emsp;密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符。

&emsp;&emsp;此题，如果写成多个正则来判断，比较容易。但要写成一个正则就比较困难。

&emsp;&emsp;那么，我们就来挑战一下。看看我们对位置的理解是否深刻。

#### 2.4.3.1 简化

&emsp;&emsp;不考虑“但必须至少包括 2 种字符”这一条件。我们可以容易写出：

```js
var regex = /^[0-9A-Za-z]{6,12}$/;
```

#### 2.4.3.2. 判断是否包含有某一种字符

&emsp;&emsp;假设，要求的必须包含数字，怎么办？此时我们可以使用 (?=.\*[0-9]) 来做。

因此正则变成：

```js
var regex = /(?=.*[0-9])^[0-9A-Za-z]{6,12}$/;
```

#### 2.4.3.3 同时包含具体两种字符

&emsp;&emsp;比如同时包含数字和小写字母，可以用 (?=._[0-9])(?=._[a-z]) 来做。

因此正则变成：

```js
var regex = /(?=.*[0-9])(?=.*[a-z])^[0-9A-Za-z]{6,12}$/;
```

#### 2.4.3.4. 解答

我们可以把原题变成下列几种情况之一：

• 同时包含数字和小写字母<br>
• 同时包含数字和大写字母<br>
• 同时包含小写字母和大写字母<br>
• 同时包含数字、小写字母和大写字母<br>
• 以上的 4 种情况是或的关系（实际上，可以不用第 4 条）。

最终答案是：

```js
var regex = /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-
Z]))^[0-9A-Za-z]{6,12}$/;
console.log( regex.test("1234567") ); // false 全是数字
console.log( regex.test("abcdef") ); // false 全是小写字母
console.log( regex.test("ABCDEFGH") ); // false 全是大写字母
console.log( regex.test("ab23C") ); // false 不足6位
console.log( regex.test("ABCDEF234") ); // true 大写字母和数字
console.log( regex.test("abcdEF234") ); // true 三者都有
```

#### 2.4.3.5. 解惑

上面的正则看起来比较复杂，只要理解了第二步，其余就全部理解了。

`/(?=.*[0-9])^[0-9A-Za-z]{6,12}$/`

对于这个正则，我们只需要弄明白 (?=.\*[0-9])^ 即可。

分开来看就是 (?=.\*[0-9]) 和 ^。

表示开头前面还有个位置（当然也是开头，即同一个位置，想想之前的空字符类比）。

(?=._[0-9]) 表示该位置后面的字符匹配 ._[0-9]，即，有任何多个任意字符，后面再跟个数字。

翻译成大白话，就是接下来的字符，必须包含个数字。

#### 2.4.3.6. 另外一种解法

“至少包含两种字符”的意思就是说，不能全部都是数字，也不能全部都是小写字母，也不能全部都是大写字母。

那么要求“不能全部都是数字”，怎么做呢？ (?!p) 出马！

对应的正则是：

```js
var regex = /(?!^[0-9]{6,12}$)^[0-9A-Za-z]{6,12}$/;
```

三种“都不能”呢？

最终答案是：

```js
var regex =
  /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/;
console.log(regex.test("1234567")); // false 全是数字
console.log(regex.test("abcdef")); // false 全是小写字母
console.log(regex.test("ABCDEFGH")); // false 全是大写字母
console.log(regex.test("ab23C")); // false 不足6位
console.log(regex.test("ABCDEF234")); // true 大写字母和数字
console.log(regex.test("abcdEF234")); // true 三者都有
```
