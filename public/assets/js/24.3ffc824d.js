(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{588:function(s,e,n){"use strict";n.r(e);var a=n(5),t=Object(a.a)({},(function(){var s=this,e=s.$createElement,n=s._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("p",[s._v("Javascript变量是松散类型的，变量只是特定时间点一个特定值的名称而已。")]),s._v(" "),n("h3",{attrs:{id:"原始值和引用值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原始值和引用值"}},[s._v("#")]),s._v(" 原始值和引用值")]),s._v(" "),n("p",[s._v("ECMAScript变量包含两种不同类型的数据： 原始值和引用值。"),n("strong",[s._v("原始值")]),s._v("为最简单的数据，"),n("strong",[s._v("引用值")]),s._v("则是由多个值构成的对象。\n六种原始值： string 、undefiend  、 null 、 boolean 、number 和 symbol , 保存原始值的变量是按值访问的，因为我们操作的是存储在变量中的实际值。\n"),n("strong",[s._v("引用值")]),s._v("：保存在内存中的对象。 与其他语言不同的是，javascript不允许直接访问内存位置，因为不能直接操作对象所在的内存空间，==在操作对象时，实际上操作的是对该对象的引用而非实际的对象本身，为此保存引用值的变量是按引用（by reference）访问的。==")]),s._v(" "),n("h3",{attrs:{id:"动态属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态属性"}},[s._v("#")]),s._v(" 动态属性")]),s._v(" "),n("p",[s._v("原始值和引用值的定义方式都是创建一个对象， 然后给它赋值。\n对于引用值来说，可以随时添加、修改和删除其属性和方法。\n而原始值则不能拥有属性，显示undefined")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("let person = new object();\nperson.name = 'JIN'\n\nlet str = 'jin';\nstr.age = 21;\nconsolel.log(str.age) //undefined\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("h3",{attrs:{id:"复制值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#复制值"}},[s._v("#")]),s._v(" 复制值")]),s._v(" "),n("p",[s._v("原始值和引用值的复制是不相同的。\n原始值的复制是独立的、互不干扰。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("let num1 = 4;\nlet num2 = num1;  // num1 和 num2独立且互不干扰\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[s._v("引用值的变量赋给另一个变量的时候，存储在变量中的值也会被复制到新变量所在的位置，但是这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量都指向同一对象，一个对象上的变化会在另一个对象上反映出来。")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("let obj1 = new Object();\nlet obj2 = obj1;\nobj1.name = 'JIN';\nconsole.log(obj2.name) // JIN\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("h3",{attrs:{id:"确定类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#确定类型"}},[s._v("#")]),s._v(" 确定类型")]),s._v(" "),n("p",[n("strong",[s._v("typeof")]),s._v(" 适合判断一个变量是否 字符串、数值、布尔值或者undefiend， 如果值是对象或者null的时候，typeof返回均为object\n"),n("strong",[s._v("instanceof")]),s._v(" 操作符 可以用来判断引用类型\n语法： result = variable instanceof constructor")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("console.log(person instanceof Object)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])])])}),[],!1,null,null,null);e.default=t.exports}}]);